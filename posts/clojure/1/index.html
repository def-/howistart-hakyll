<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <title>How I Start.</title>

    <link href="../../../posts.rss" rel="alternate" type="application/rss+xml" title="How I Start." />

    <!-- Bootstrap core CSS -->
    <link href="../../../css/readable.min.css" rel="stylesheet" />

    <!-- Custom CSS for the 'Thumbnail Gallery' Template -->
    <link href="../../../css/1-col-portfolio.css" rel="stylesheet" />
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
      table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
      margin: 0; padding: 0; vertical-align: baseline; border: none; }
      table.sourceCode { width: 100%; line-height: 100%; }
      td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
      td.sourceCode { padding-left: 5px; }
      code > span.kw { color: #007020; font-weight: bold; }
      code > span.dt { color: #902000; }
      code > span.dv { color: #40a070; }
      code > span.bn { color: #40a070; }
      code > span.fl { color: #40a070; }
      code > span.ch { color: #4070a0; }
      code > span.st { color: #4070a0; }
      code > span.co { color: #60a0b0; font-style: italic; }
      code > span.ot { color: #007020; }
      code > span.al { color: #ff0000; font-weight: bold; }
      code > span.fu { color: #06287e; }
      code > span.er { color: #ff0000; font-weight: bold; }
    </style>

  </head>
  <body>
    <nav class="navbar navbar-top navbar-inverse" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a class="navbar-brand" href="../../../">How I Start.</a>
    </div>

    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li class="category"><a href="../../../posts/clojure">clojure</a></li><li class="category"><a href="../../../posts/cpp">cpp</a></li><li class="category"><a href="../../../posts/elixir">elixir</a></li><li class="category"><a href="../../../posts/erlang">erlang</a></li><li class="category"><a href="../../../posts/go">go</a></li><li class="category"><a href="../../../posts/haskell">haskell</a></li><li class="category"><a href="../../../posts/nim">nim</a></li><li class="category"><a href="../../../posts/ruby">ruby</a></li>
      </ul>

      <ul class="nav navbar-nav navbar-right">
        <li><a href="../../../about.html">About</a></li>
      </ul>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>


    <div class="container">
      <div id="content">
        <div class="row">
  <div class="col-lg-12">
    <h1 class="page-header">
      Clojure <small>with Carin Meier</small>
    </h1>
  </div>
</div>

<div class="row">
  <div class="col-lg-10 col-lg-offset-1">
    <p>We are going to explore Clojure by creating a fun project together. In particular, we will create a twitter bot that creates its text based on a mashup of <a href="http://www.gutenberg.org/files/13650/13650-h/13650-h.htm">Edward Lear’s poetry</a>, and a goodly selection of functional programming text taken from Wikipedia.</p>
<p>Why Edward Lear and Functional Programming? First, because I really enjoy his poetry. I fondly remember reading his poetry to my children. Some of my favorite poems are <a href="http://www.gutenberg.org/files/13650/13650-h/13650-h.htm#pobble">The Pobble Who Has No Toes</a>, <a href="http://www.gutenberg.org/files/13650/13650-h/13650-h.htm#quangle">The Quangle Wangle’s Hat</a>, and <a href="http://www.gutenberg.org/files/13650/13650-h/13650-h.htm#jumblies">The Jumblies</a>. The whimsical nature of his poetry, like his contemporary Lewis Carroll, have great appeal to me. It is only natural that I should want to combine it with my other love, functional programming. In fact, I feel that some of of terms in functional programming like <em>monad</em> and <em>functor</em>, could fit right in with Edward Lear’s <em>Nonsense Songs</em>. This humble bot aims to unite the spheres of functional programming and nonsense poetry.</p>
<p>This tutorial will start with getting started with a basic Clojure project and editor. Then, we’ll build up our tweet generator with a <a href="http://en.wikipedia.org/wiki/Markov_chain">Markov Chain</a>. Finally, we will deploy our code to <a href="https://www.heroku.com/">Heroku</a> and hook it up to a twitter account, where it will live and tweet all on its own.</p>
<p>Since this walk through is geared to explain how I work in particular, we will start my essential ingredient to any coding project … <em>tea</em>. I brew myself a cup of <em>PG Tips</em> tea with a splash of milk, then I sit down and fire up my trusty editor <em>Emacs</em>.</p>
<h2 id="emacs-is-a-lifestyle">Emacs is a lifestyle</h2>
<p>Emacs is more than an editor, it is a lifestyle. I also admit that the learning curve is steep. I actually only know about 4% of Emacs. This is completely normal given that the learning curve for the editor looks like a squiggly curlicue.</p>
<div class="figure">
<img src="http://c4.staticflickr.com/8/7598/16914999852_995b77a811_z.jpg" />

</div>
<p>Nevertheless, once I started using Emacs for Clojure and experienced the interactive nature of the code and the REPL, (Read Eval Print Loop), I was hooked. I use a customized version of <a href="https://github.com/technomancy/emacs-starter-kit">Emacs Starter Kit</a>. I also find the <a href="https://github.com/sellout/emacs-color-theme-solarized">Solarized Color-scheme</a> a must for my eyes. For Clojure code, I use <a href="https://github.com/clojure-emacs/cider">Cider for Emacs</a>, which gives me the incredible interactive code experience that I was mentioning. If you are looking to try out Emacs I would recommend getting the starter kit and grabbing a good tutorial like this <a href="http://www.jesshamrick.com/2012/09/10/absolute-beginners-guide-to-emacs/">one</a>.</p>
<p>Now that we have our tea and Emacs editor open, It is time to actually get our Clojure project created. For this I use <a href="http://leiningen.org/">Leiningen</a>.</p>
<h2 id="getting-the-basic-project-setup">Getting the basic project setup</h2>
<p><em>As we go through the walkthrough, feel free to reference the full <a href="https://github.com/gigasquid/markov-elear">source code on github</a>.</em></p>
<p>Leiningen helps you create, manage, and automate your Clojure project. If you don’t already have Leiningen installed, follow the install <a href="http://leiningen.org/">instructions</a> and download it. We are going to call our project <code>markov-elear</code>, so to create a project we just type the <code>lein new</code> command at our prompt:</p>
<pre><code>lein new markov-elear</code></pre>
<p>This will create a basic project skeleton for us to work with. Next, <code>cd</code> into the directory.</p>
<pre><code>cd markov-elear</code></pre>
<p>The default src file that it creates is <em>src/markov_elear/core.clj</em>. This is the first thing to change. We want a more meaningful file name. For our purposes, let’s rename it to <em>src/markov_elear/generator.clj</em>.</p>
<pre><code>mv src/markov_elear/core.clj src/markov_elear/generator.clj</code></pre>
<p>There is also a skeleton test file that is created in <em>test/markov_elear/core_test.clj</em>. We will want to do the same thing to it as well.</p>
<pre><code>mv test/markov_elear/core_test.clj test/markov_elear/generator_test.clj</code></pre>
<p>Next, open up the <em>generator.clj</em> file in Emacs. It has been created with the Leiningen template, so there is code already there that looks like:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.core)

(<span class="kw">defn</span><span class="fu"> foo</span>
  <span class="st">&quot;I don't do a whole lot.&quot;</span>
  [x]
  (<span class="kw">println</span> x <span class="st">&quot;Hello, World!&quot;</span>))</code></pre></div>
<p>Since we changed our file to be named <em>generator.clj</em>, we also need to change the namespace to match it. Let’s also get rid of the <code>foo</code> function. It should now look like:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.generator)</code></pre></div>
<p>Go ahead and open up the test file as well <em>test/markov_elear/generator_test.clj</em>. It also has some sample code in it from the Leiningen template. It looks like:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.core-test
  (<span class="kw">:require</span> [clojure.<span class="kw">test</span> <span class="kw">:refer</span> <span class="kw">:all</span>]
            [markov-elear.core <span class="kw">:refer</span> <span class="kw">:all</span>]))

(<span class="kw">deftest</span><span class="fu"> a-test</span>
  (<span class="kw">testing</span> <span class="st">&quot;FIXME, I fail.&quot;</span>
    (<span class="kw">is</span> (<span class="kw">=</span> <span class="dv">0</span> <span class="dv">1</span>))))</code></pre></div>
<p>Change the namespace in the test to match the filename as well as the require to be that of <code>markov-elear-generator</code>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.generator-test
  (<span class="kw">:require</span> [clojure.<span class="kw">test</span> <span class="kw">:refer</span> <span class="kw">:all</span>]
            [markov-elear.generator <span class="kw">:refer</span> <span class="kw">:all</span>]))

(<span class="kw">deftest</span><span class="fu"> a-test</span>
  (<span class="kw">testing</span> <span class="st">&quot;FIXME, I fail.&quot;</span>
    (<span class="kw">is</span> (<span class="kw">=</span> <span class="dv">0</span> <span class="dv">1</span>))))</code></pre></div>
<p>At this point, we should now be able to run <code>lein test</code> from the command prompt and see our sample test fail.</p>
<pre><code>lein test markov-elear.generator-test

lein test :only markov-elear.generator-test/a-test

FAIL in (a-test) (generator_test.clj:7)
FIXME, I fail.
expected: (= 0 1)
  actual: (not (= 0 1))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
Tests failed.
</code></pre>
<p>Fantastic. Our project is all set up. We are ready to <em>jack-in</em> with Emacs and Cider and start coding.</p>
<h2 id="cider-jack-in-and-experiment">Cider Jack In and Experiment</h2>
<p>Here is where we start to use the interactive nature of Clojure and Emacs in earnest. With the <em>generator.clj</em> file open in Emacs, type <code>M-x cider-jack-in</code>. This will start a nREPL server for our project, so we can actively start to experiment with our code. This early stage is a bit like playing with putty before sculpting. It allows us to quickly try out different approaches and get a feel for data constructs to use. For example, first put your cursor after the namespace form and hit <code>C-x C-e</code> to evaluate the form.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.generator)</code></pre></div>
<p>You are now all set to the generator namespace for your evaluation.</p>
<p>Next, type into <code>generator.clj</code> the line:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">1</span>)</code></pre></div>
<p>At this point, you can put your cursor at the end of the form and again hit <code>C-x C-e</code> you will see the result <code>2</code> appear in the mini-buffer at the bottom of the screen.</p>
<p>Now, we are ready to experiment with Markov Chains. The first thing we need is some small example to play with. Consider the following text.</p>
<pre><code>&quot;And the Golden Grouse And the Pobble who&quot;</code></pre>
<p>To construct a Markov Chain, we need to transform this text into a chain of prefixes and suffixes. In Markov chains, the length of the prefix can vary. The larger the prefix, the more predictable the text becomes, while the smaller the prefix size, the more random. In this case, we are going to use a prefix size of 2. We want to break up the original text into chunks of two words. The suffix is the next word that comes after.</p>
<pre><code>|Prefix        | Suffix
| -------------|-------------
| And the      | Golden
| the Golden   | Grouse
| Grouse And   | the
| And the      | Pobble
| the Pobble   | who
| Pobble who   | nil</code></pre>
<p>This table becomes a guide for us in walking the chain to generate new text. If we start at a random place in the table, we can generate some text by following some simple rules.</p>
<ol style="list-style-type: decimal">
<li>Choose a prefix to start. Your result string starts as this prefix.</li>
<li>Take the suffix that goes with the prefix. Add the suffix to your result string. Also, add the last word of the prefix to the suffix, this is your new prefix.</li>
<li>Look up your new prefix in the table and continue until there is no suffix.</li>
<li>The result string is your generated text.</li>
</ol>
<p>From our table, let’s start with the prefix <em>the Pobble</em>.</p>
<ol style="list-style-type: decimal">
<li>Our starting prefix is <em>the Pobble</em>. Our result string will be initialized to it.</li>
<li>Look up the prefix in the table. The suffix that goes with it is <em>who</em>. Add the suffix to the result string. The new prefix is the last word from the prefix and the suffix. So the new prefix is <em>Pobble who</em>.</li>
<li>Look up up the prefix in the table, the suffix is nil. This means we have reached the end of the chain. Our resulting text is <em>the Pobble who</em>.</li>
</ol>
<p>Things get interesting when there is more than one entry for a prefix. Notice that <em>And the</em> is in the table twice. This means that there is a choice of what entry to use and what suffix. We can randomly choose which one to use in our Markov Chain walk. As a result, our text will be randomly generated. If start with the prefix <em>And the</em> we have different possibilities for the resulting text. It could be</p>
<ul>
<li>And the Pobble who</li>
<li>And the Golden Grouse And the Pobble who</li>
<li>And the Golden Grouse And the Golden Grouse And the Pobble who</li>
<li>And the Golden Grouse And the Golden Grouse And the Golden Grouse And the Pobble who</li>
<li>etc…</li>
</ul>
<p>Since we could get into repeating chains, we should also put a terminating condition of the total length of our resulting text as well.</p>
<p>Now that we know the general idea of what we want to do, let’s start small and start experimenting.</p>
<h3 id="baby-steps">Baby steps</h3>
<p>First, let’s take our example text and put it into code to play with in the REPL.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> example </span><span class="st">&quot;And the Golden Grouse And the Pobble who&quot;</span>)
<span class="co">;; -&gt; #'markov-elear.core/example</span></code></pre></div>
<p>Now, we are going to want to split up this text by spaces. This is a job for <code>clojure.string/split</code>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> words </span>(clojure.string/split example <span class="st">#&quot; &quot;</span>))
words
<span class="co">;; -&gt; [&quot;And&quot; &quot;the&quot; &quot;Golden&quot; &quot;Grouse&quot; &quot;And&quot; &quot;the&quot; &quot;Pobble&quot; &quot;who&quot;]</span></code></pre></div>
<p>We also need to divide up these words in chunks of 3. Clojure’s <code>partition-all</code> will be perfect for this. We are going to partition the word list in chunks of three.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> word-transitions </span>(partition-all <span class="dv">3</span> <span class="dv">1</span> words))
word-transitions
<span class="co">;; -&gt; ((&quot;And&quot; &quot;the&quot; &quot;Golden&quot;)</span>
<span class="co">;;     (&quot;the&quot; &quot;Golden&quot; &quot;Grouse&quot;)</span>
<span class="co">;;     (&quot;Golden&quot; &quot;Grouse&quot; &quot;And&quot;)</span>
<span class="co">;;     (&quot;Grouse&quot; &quot;And&quot; &quot;the&quot;)</span>
<span class="co">;;     (&quot;And&quot; &quot;the&quot; &quot;Pobble&quot;)</span>
<span class="co">;;     (&quot;the&quot; &quot;Pobble&quot; &quot;who&quot;)</span>
<span class="co">;;     (&quot;Pobble&quot; &quot;who&quot;)</span>
<span class="co">;;     (&quot;who&quot;))</span></code></pre></div>
<p>This is nice, but we really need to get it into a word-chain format. Ideally it would a map with the prefixes as the key and then have a set of suffixes to choose from. So that the prefix of <em>And the</em> would look like</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">{[<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>]} #{<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;Golden&quot;</span>}</code></pre></div>
<p>A map with the key being the vector of prefix words and the value being the set of suffixes.</p>
<p>We need to map through the list of word-transitions and build this up somehow. Perhaps <code>merge-with</code> will help us out.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">merge-with</span> <span class="kw">concat</span> {<span class="kw">:a</span> [<span class="dv">1</span>]} {<span class="kw">:a</span> [<span class="dv">3</span>]})
<span class="co">;; -&gt; {:a (1 3)}</span></code></pre></div>
<p><code>merge-with</code> will allow us to combine the prefixes with multiple suffixes in a map form, but we really want it in a set. Time to experiment some more.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">merge-with</span> clojure.set/union {<span class="kw">:a</span> #{<span class="dv">1</span>}} {<span class="kw">:a</span> #{<span class="dv">2</span>}})
<span class="co">;; -&gt; {:a #{1 2}}</span></code></pre></div>
<p>Yes, that will do nicely. Let’s try this out in a <code>reduce</code> over the <code>word-transitions</code>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">reduce</span> (<span class="kw">fn</span> [r t] (<span class="kw">merge-with</span> clojure.set/union r
                               (<span class="kw">let</span> [[a b c] t]
                                 {[a b] (<span class="kw">if</span> c #{c} #{})})))
          {}
          word-transitions)
<span class="co">;; {[&quot;who&quot; nil] #{},</span>
<span class="co">;;  [&quot;Pobble&quot; &quot;who&quot;] #{},</span>
<span class="co">;;  [&quot;the&quot; &quot;Pobble&quot;] #{&quot;who&quot;},</span>
<span class="co">;;  [&quot;Grouse&quot; &quot;And&quot;] #{&quot;the&quot;},</span>
<span class="co">;;  [&quot;Golden&quot; &quot;Grouse&quot;] #{&quot;And&quot;},</span>
<span class="co">;;  [&quot;the&quot; &quot;Golden&quot;] #{&quot;Grouse&quot;},</span>
<span class="co">;;  [&quot;And&quot; &quot;the&quot;] #{&quot;Pobble&quot; &quot;Golden&quot;}}</span></code></pre></div>
<h2 id="tangible-turn-to-tests">Tangible turn to tests</h2>
<p>We have been experimenting in the REPL, but now that we have a feel for where we are going it is time to write some tests. I really like to use the <a href="https://github.com/jakemcc/lein-test-refresh">lein-test-refesh plugin</a>. It will continually rerun the tests whenever we change something in our files. I find the feedback loop is much faster then running <code>lein test</code> alone. It also takes care of reloading all the namespaces for you, so I don’t run into problems where my REPL environment gets out of sync with my code. To add it to your project, simply add the following to your <em>project.clj</em> file.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="kw">:profiles</span> {<span class="kw">:dev</span> {<span class="kw">:plugins</span> [[com.jakemccrary/lein-test-refresh <span class="st">&quot;0.7.0&quot;</span>]]}}</code></pre></div>
<p>Now, you can start it up from your prompt by running</p>
<pre><code>lein test-refresh</code></pre>
<p>First, let’s get rid of the sample test and replace it with a real one. We want this test to be about the word chain that we were experimenting with.</p>
<h3 id="building-the-word-chain">Building the Word Chain</h3>
<p>Add this to your <em>generator_test.clj</em> file.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.generator-test
  (<span class="kw">:require</span> [clojure.<span class="kw">test</span> <span class="kw">:refer</span> <span class="kw">:all</span>]
            [markov-elear.generator <span class="kw">:refer</span> <span class="kw">:all</span>]))

(<span class="kw">deftest</span><span class="fu"> test-word-chain</span>
  (<span class="kw">testing</span> <span class="st">&quot;it produces a chain of the possible two step transitions between suffixes and prefixes&quot;</span>
    (<span class="kw">let</span> [example '((<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span>)
                    (<span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span>)
                    (<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>)
                    (<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>))]
      (<span class="kw">is</span> (<span class="kw">=</span> {[<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>] #{<span class="st">&quot;who&quot;</span>}
              [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span>] #{<span class="st">&quot;Grouse&quot;</span>}
              [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>] #{<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;Golden&quot;</span>}}
             (word-chain example))))))</code></pre></div>
<p>As you save the file, you will notice the test failing in your <code>lein test-refresh</code> window. This is because we haven’t written the <em>word-chain</em> function yet. After all of our experimentation, we know exactly what we need to do. Add the following function to your <em>generator.clj</em> file.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> word-chain </span>[word-transitions]
  (<span class="kw">reduce</span> (<span class="kw">fn</span> [r t] (<span class="kw">merge-with</span> clojure.set/union r
                               (<span class="kw">let</span> [[a b c] t]
                                 {[a b] (<span class="kw">if</span> c #{c} #{})})))
          {}
          word-transitions))</code></pre></div>
<p>Your test should now pass.</p>
<p>What about generating the word chain from an string of text? When we were experimenting in the REPL, we saw that using <code>parition-all</code> was going to be useful. Let’s add a test for that now in <em>generator_test.clj</em>. We want to parse an input string that has spaces or new lines.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">deftest</span><span class="fu"> test-text-&gt;word-chain</span>
  (<span class="kw">testing</span> <span class="st">&quot;string with spaces and newlines&quot;</span>
    (<span class="kw">let</span> [example <span class="st">&quot;And the Golden Grouse</span>\n<span class="st">And the Pobble who&quot;</span>]
     (<span class="kw">is</span> (<span class="kw">=</span> {[<span class="st">&quot;who&quot;</span> nil] #{}
             [<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>] #{}
             [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>] #{<span class="st">&quot;who&quot;</span>}
             [<span class="st">&quot;Grouse&quot;</span> <span class="st">&quot;And&quot;</span>] #{<span class="st">&quot;the&quot;</span>}
             [<span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span>] #{<span class="st">&quot;And&quot;</span>}
             [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span>] #{<span class="st">&quot;Grouse&quot;</span>}
             [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>] #{<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;Golden&quot;</span>}}
            (text-&gt;word-chain example))))))</code></pre></div>
<p>To make it pass, add the <code>text-&gt;word-chain</code> function in the <em>generator_test.clj</em>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> text-&gt;word-chain </span>[s]
  (<span class="kw">let</span> [words (clojure.string/split s <span class="st">#&quot;[\s|</span>\n<span class="st">]&quot;</span>)
        word-transitions (partition-all <span class="dv">3</span> <span class="dv">1</span> words)]
    (word-chain word-transitions)))</code></pre></div>
<p>Now that we have our word-chain, we are going to need a way to walk the chain, given a beginning prefix, and come up with our resulting text.</p>
<h3 id="random-walking-the-chain">Random Walking the Chain</h3>
<p>Going back to our test file <em>generator_test.clj</em>, add a new test for a <code>walk-chain</code> function that we want:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">deftest</span><span class="fu"> test-walk-chain</span>
  (<span class="kw">let</span> [chain {[<span class="st">&quot;who&quot;</span> nil] #{},
               [<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>] #{},
               [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>] #{<span class="st">&quot;who&quot;</span>},
               [<span class="st">&quot;Grouse&quot;</span> <span class="st">&quot;And&quot;</span>] #{<span class="st">&quot;the&quot;</span>},
               [<span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span>] #{<span class="st">&quot;And&quot;</span>},
               [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span>] #{<span class="st">&quot;Grouse&quot;</span>},
               [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>] #{<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;Golden&quot;</span>}}]
    (<span class="kw">testing</span> <span class="st">&quot;dead end&quot;</span>
      (<span class="kw">let</span> [prefix [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>]]
        (<span class="kw">is</span> (<span class="kw">=</span> [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>]
               (walk-chain prefix chain prefix)))))))</code></pre></div>
<p>Given a the starting prefix of <code>[&quot;the&quot; &quot;Pobble&quot;]</code>, it will walk our chain until it reaches the a dead end of there being no more suffixes. The result should be <code>[&quot;the&quot; &quot;Pobble&quot; &quot;who&quot;]</code>.</p>
<p>Going back to our <em>generator.clj</em> file, we can start constructing a function to do this</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> walk-chain </span>[prefix chain result]
  (<span class="kw">let</span> [suffixes (<span class="kw">get</span> chain prefix)]
    (<span class="kw">if</span> (<span class="kw">empty?</span> suffixes)
      result
      (<span class="kw">let</span> [suffix (<span class="kw">first</span> (shuffle suffixes))
            new-prefix [(<span class="kw">last</span> prefix) suffix]]
        (<span class="kw">recur</span> new-prefix chain (<span class="kw">conj</span> result suffix))))))</code></pre></div>
<p>It takes the prefix and get the suffixes associated with it. If there are no suffixes, it terminates and returns the result. Otherwise, it uses <code>shuffle</code> to pick a random suffix. Then it constructs the new prefix from the last part of the current prefix and the suffix. Finally, it recurs into the function using the <code>new-prefix</code> and adding the suffix to the result.</p>
<p>We have another passing test, but we still need to consider the other walking of the chain where it has a choice. Go ahead and add a test for that now too.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">deftest</span><span class="fu"> test-walk-chain</span>
  (<span class="kw">let</span> [chain {[<span class="st">&quot;who&quot;</span> nil] #{},
               [<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>] #{},
               [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>] #{<span class="st">&quot;who&quot;</span>},
               [<span class="st">&quot;Grouse&quot;</span> <span class="st">&quot;And&quot;</span>] #{<span class="st">&quot;the&quot;</span>},
               [<span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span>] #{<span class="st">&quot;And&quot;</span>},
               [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span>] #{<span class="st">&quot;Grouse&quot;</span>},
               [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>] #{<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;Golden&quot;</span>}}]
    (<span class="kw">testing</span> <span class="st">&quot;dead end&quot;</span>
      (<span class="kw">let</span> [prefix [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>]]
        (<span class="kw">is</span> (<span class="kw">=</span> [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>]
               (walk-chain prefix chain prefix)))))
    (<span class="kw">testing</span> <span class="st">&quot;multiple choices&quot;</span>
      (with-redefs [shuffle (<span class="kw">fn</span> [c] c)]
        (<span class="kw">let</span> [prefix [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>]]
          (<span class="kw">is</span> (<span class="kw">=</span> [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>]
                 (walk-chain prefix chain prefix))))))))</code></pre></div>
<p>Because we have randomness to deal with, we can use <code>with-redefs</code> to redefine <code>shuffle</code> to always return the original collection for us. We also need to deal with repeating chains. We will have to give it another termination condition, like a word or character length for termination. Since our bot is destined for twitter, a 140 char limit seems reasonable.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">deftest</span><span class="fu"> test-walk-chain</span>
  (<span class="kw">let</span> [chain {[<span class="st">&quot;who&quot;</span> nil] #{},
               [<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>] #{},
               [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>] #{<span class="st">&quot;who&quot;</span>},
               [<span class="st">&quot;Grouse&quot;</span> <span class="st">&quot;And&quot;</span>] #{<span class="st">&quot;the&quot;</span>},
               [<span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span>] #{<span class="st">&quot;And&quot;</span>},
               [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span>] #{<span class="st">&quot;Grouse&quot;</span>},
               [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>] #{<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;Golden&quot;</span>}}]
    (<span class="kw">testing</span> <span class="st">&quot;dead end&quot;</span>
      (<span class="kw">let</span> [prefix [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>]]
        (<span class="kw">is</span> (<span class="kw">=</span> [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>]
               (walk-chain prefix chain prefix)))))
    (<span class="kw">testing</span> <span class="st">&quot;multiple choices&quot;</span>
      (with-redefs [shuffle (<span class="kw">fn</span> [c] c)]
        (<span class="kw">let</span> [prefix [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>]]
          (<span class="kw">is</span> (<span class="kw">=</span> [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>]
                 (walk-chain prefix chain prefix))))))
    (<span class="kw">testing</span> <span class="st">&quot;repeating chains&quot;</span>
      (with-redefs [shuffle (<span class="kw">fn</span> [c] (<span class="kw">reverse</span> c))]
        (<span class="kw">let</span> [prefix [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>]]
          (<span class="kw">is</span> (<span class="kw">&gt;</span> <span class="dv">140</span>
                 (<span class="kw">count</span> (<span class="kw">apply</span> <span class="kw">str</span> (walk-chain prefix chain prefix)))))
          (<span class="kw">is</span> (<span class="kw">=</span> [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span> <span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span>]
                 (<span class="kw">take</span> <span class="dv">8</span> (walk-chain prefix chain prefix)))))))))</code></pre></div>
<p><em>Note: The test will actually run forever since it is stuck in an endless loop. You will have to restart your test-refresh session after you implement the solution.</em></p>
<p>Adjusting our <em>generator.clj</em>, we first need a helper function that will turn our result chain into a string with spaces, so that we can count the chars and make sure that they are under the limit. We will call it <code>chain-&gt;text</code>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> chain-&gt;text </span>[chain]
  (<span class="kw">apply</span> <span class="kw">str</span> (<span class="kw">interpose</span> <span class="st">&quot; &quot;</span> chain)))</code></pre></div>
<p>It takes a chain like <code>[&quot;And&quot; &quot;the&quot; &quot;Pobble&quot; &quot;who&quot;]</code> and gives us back the display text.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(chain-&gt;text [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>])
<span class="co">;; -&gt; &quot;And the Pobble who&quot;</span></code></pre></div>
<p>Now we can add the char limit counting to our <code>walk-chain</code> function.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> chain-&gt;text </span>[chain]
  (<span class="kw">apply</span> <span class="kw">str</span> (<span class="kw">interpose</span> <span class="st">&quot; &quot;</span> chain)))

(<span class="kw">defn</span><span class="fu"> walk-chain </span>[prefix chain result]
  (<span class="kw">let</span> [suffixes (<span class="kw">get</span> chain prefix)]
    (<span class="kw">if</span> (<span class="kw">empty?</span> suffixes)
      result
      (<span class="kw">let</span> [suffix (<span class="kw">first</span> (shuffle suffixes))
            new-prefix [(<span class="kw">last</span> prefix) suffix]
            result-with-spaces (chain-&gt;text result)
            result-char-count (<span class="kw">count</span> result-with-spaces)
            suffix-char-count (<span class="kw">inc</span> (<span class="kw">count</span> suffix))
            new-result-char-count (<span class="kw">+</span> result-char-count suffix-char-count)]
        (<span class="kw">if</span> (<span class="kw">&gt;=</span> new-result-char-count <span class="dv">140</span>)
          result
          (<span class="kw">recur</span> new-prefix chain (<span class="kw">conj</span> result suffix)))))))</code></pre></div>
<p>We check the <code>result-char-count</code> and the chosen <code>suffix-char-count</code> before we recur, so that we can ensure that it doesn’t go over 140 chars. If it is going to go over the limit, we return the result and do not <code>recur</code>.</p>
<p>What we need now is another higher level function that, when given a prefix and a word chain, will return the resulting text.</p>
<h3 id="taking-a-start-text-phrase-walking-the-chain-and-returning-text.">Taking A Start Text Phrase, Walking the Chain, and Returning Text.</h3>
<p>Going back to the <em>generator_test.clj</em> file, let’s go ahead and write the test. We will use <code>with-redefs</code> again to control our randomness.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">deftest</span><span class="fu"> test-generate-text</span>
  (with-redefs [shuffle (<span class="kw">fn</span> [c] c)]
    (<span class="kw">let</span> [chain {[<span class="st">&quot;who&quot;</span> nil] #{}
                 [<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;who&quot;</span>] #{}
                 [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Pobble&quot;</span>] #{<span class="st">&quot;who&quot;</span>}
                 [<span class="st">&quot;Grouse&quot;</span> <span class="st">&quot;And&quot;</span>] #{<span class="st">&quot;the&quot;</span>}
                 [<span class="st">&quot;Golden&quot;</span> <span class="st">&quot;Grouse&quot;</span>] #{<span class="st">&quot;And&quot;</span>}
                 [<span class="st">&quot;the&quot;</span> <span class="st">&quot;Golden&quot;</span>] #{<span class="st">&quot;Grouse&quot;</span>}
                 [<span class="st">&quot;And&quot;</span> <span class="st">&quot;the&quot;</span>] #{<span class="st">&quot;Pobble&quot;</span> <span class="st">&quot;Golden&quot;</span>}}]
      (<span class="kw">is</span> (<span class="kw">=</span> <span class="st">&quot;the Pobble who&quot;</span> (generate-text <span class="st">&quot;the Pobble&quot;</span> chain)))
      (<span class="kw">is</span> (<span class="kw">=</span> <span class="st">&quot;And the Pobble who&quot;</span> (generate-text <span class="st">&quot;And the&quot;</span> chain))))))</code></pre></div>
<p>To make the test pass in our <em>generator.clj</em> file, we create the function that will take a start-phrase as a prefix and a word chain. Then it will split the start-phrase by spaces, so that it will match up to our prefix keys. Next, it will use <code>walk-chain</code> to get the resulting text chain. Finally, it will turn the result text chain into plain text with <code>chain-&gt;text</code>.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> generate-text</span>
  [start-phrase word-chain]
  (<span class="kw">let</span> [prefix (clojure.string/split start-phrase <span class="st">#&quot; &quot;</span>)
        result-chain (walk-chain prefix word-chain prefix)
        result-text (chain-&gt;text result-chain)]
    result-text))</code></pre></div>
<p>Taking a moment to recap, this is what we have so far:</p>
<ul>
<li>We can take string, parse it and turn it into a word chain.</li>
<li>We can take an input phrase and word chain and generate some new text by taking a random walk in the chain.</li>
</ul>
<p>What we are missing is a way to <em>train</em> our bot, by reading in some files of text and building out the chain that it will walk.</p>
<h3 id="training-the-bot-by-reading-input-files">Training the bot by reading input files</h3>
<p>To <em>train</em> our bot, we need to be able to give it a text file and have it turn it into a word chain. Our first text selection will be from <a href="http://www.gutenberg.org/files/13650/13650-h/13650-h.htm#quangle">The Quangle Wangle’s Hat</a>.</p>
<p>Making it easier on ourselves, we will do some slight formatting of the text. Save it in a file called <em>resources/quangle-wangle.txt</em>.</p>
<pre><code>On the top of the Crumpetty Tree
The Quangle Wangle sat,
But his face you could not see,
On account of his Beaver Hat.
For his Hat was a hundred and two feet wide,
With ribbons and bibbons on every side,
And bells, and buttons, and loops, and lace,
So that nobody ever could see the face
Of the Quangle Wangle Quee.
The Quangle Wangle said
To himself on the Crumpetty Tree,
&quot;Jam, and jelly, and bread
Are the best of food for me!
But the longer I live on this Crumpetty Tree
The plainer than ever it seems to me
That very few people come this way
And that life on the whole is far from gay!&quot;
Said the Quangle Wangle Quee.
But there came to the Crumpetty Tree
Mr. and Mrs. Canary;
And they said, &quot;Did ever you see
Any spot so charmingly airy?
May we build a nest on your lovely Hat?
Mr. Quangle Wangle, grant us that!
O please let us come and build a nest
Of whatever material suits you best,
Mr. Quangle Wangle Quee!&quot;
And besides, to the Crumpetty Tree
Came the Stork, the Duck, and the Owl;
The Snail and the Bumble-Bee,
The Frog and the Fimble Fowl
(The Fimble Fowl, with a Corkscrew leg);
And all of them said, &quot;We humbly beg
We may build our homes on your lovely Hat,--
Mr. Quangle Wangle, grant us that!
Mr. Quangle Wangle Quee!&quot;
And the Golden Grouse came there,
And the Pobble who has no toes,
And the small Olympian bear,
And the Dong with a luminous nose.
And the Blue Baboon who played the flute,
And the Orient Calf from the Land of Tute,
And the Attery Squash, and the Bisky Bat,--
All came and built on the lovely Hat
Of the Quangle Wangle Quee.
And the Quangle Wangle said
To himself on the Crumpetty Tree,
&quot;When all these creatures move
What a wonderful noise there'll be!&quot;
And at night by the light of the Mulberry moon
They danced to the Flute of the Blue Baboon,
On the broad green leaves of the Crumpetty Tree,
And all were as happy as happy could be,
With the Quangle Wangle Quee.</code></pre>
<p>We can now use <code>clojure.java.io/resource</code> to open the file and <code>slurp</code> to turn it into a string. From there, we can simply use our <code>text-&gt;word-chain</code> function to transform it into the word chain that we need. Add the <code>process-file</code> function to the <em>generator.clj</em> file and give it a try in the REPL.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> process-file </span>[fname]
  (text-&gt;word-chain
   (<span class="kw">slurp</span> (clojure.java.io/resource fname))))

(generate-text <span class="st">&quot;And the&quot;</span> (process-file <span class="st">&quot;quangle-wangle.txt&quot;</span>))
<span class="co">;; -&gt; &quot;And the Attery Squash, and the Bumble-Bee,</span>
<span class="co">;;     The Frog and the Bisky Bat,-- All came and built on the</span>
<span class="co">;;     Crumpetty Tree</span>
<span class="co">;;     The plainer than ever it&quot;</span></code></pre></div>
<p>Great! We just need to add some more text files. We will add some more Edward Lear Poems, As well as some text from wikipedia on Functional Programming.</p>
<ul>
<li><a href="http://www.gutenberg.org/files/13650/13650-h/13650-h.htm">The Project Gutenberg eBook, Nonsense Books, by Edward Lear</a></li>
<li>http://en.wikipedia.org/wiki/Monad_(functional_programming)</li>
<li><a href="http://en.wikipedia.org/wiki/Functional_programming" class="uri">http://en.wikipedia.org/wiki/Functional_programming</a></li>
<li><a href="http://en.wikipedia.org/wiki/Clojure" class="uri">http://en.wikipedia.org/wiki/Clojure</a></li>
</ul>
<p>After we have chosen our text selections, we define a list of input files and the final chain that is the result of all the processed text.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> files </span>[<span class="st">&quot;quangle-wangle.txt&quot;</span> <span class="st">&quot;monad.txt&quot;</span> <span class="st">&quot;clojure.txt&quot;</span> <span class="st">&quot;functional.txt&quot;</span>
            <span class="st">&quot;jumblies.txt&quot;</span> <span class="st">&quot;pelican.txt&quot;</span> <span class="st">&quot;pobble.txt&quot;</span>])
(<span class="kw">def</span><span class="fu"> functional-leary </span>(<span class="kw">apply</span> <span class="kw">merge-with</span> clojure.set/union (<span class="kw">map</span> process-file files)))</code></pre></div>
<p>Giving it a try in the REPL.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(generate-text <span class="st">&quot;On the&quot;</span> functional-leary)
<span class="co">;; -&gt; &quot;On the broad green leaves of the list. Under lazy evaluation,</span>
<span class="co">;;    the length function will return a new monadic value.</span>
<span class="co">;;    The bind operation takes&quot;</span></code></pre></div>
<p>Now we are having fun :)</p>
<h2 id="artistic-tweaking">Artistic tweaking</h2>
<p>Here is when it turns to artistic tweaking. I want to hand select a few entry prefixes, so that the text generated will tend to start out sounding like Edward Lear and have functional text mixed in.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> prefix-list </span>[<span class="st">&quot;On the&quot;</span> <span class="st">&quot;They went&quot;</span> <span class="st">&quot;And all&quot;</span> <span class="st">&quot;We think&quot;</span>
                  <span class="st">&quot;For every&quot;</span> <span class="st">&quot;No other&quot;</span> <span class="st">&quot;To a&quot;</span> <span class="st">&quot;And every&quot;</span>
                  <span class="st">&quot;We, too,&quot;</span> <span class="st">&quot;For his&quot;</span> <span class="st">&quot;And the&quot;</span> <span class="st">&quot;But the&quot;</span>
                  <span class="st">&quot;Are the&quot;</span> <span class="st">&quot;The Pobble&quot;</span> <span class="st">&quot;For the&quot;</span> <span class="st">&quot;When we&quot;</span>
                  <span class="st">&quot;In the&quot;</span> <span class="st">&quot;Yet we&quot;</span> <span class="st">&quot;With only&quot;</span> <span class="st">&quot;Are the&quot;</span>
                  <span class="st">&quot;Though the&quot;</span>  <span class="st">&quot;And when&quot;</span>
                  <span class="st">&quot;We sit&quot;</span> <span class="st">&quot;And this&quot;</span> <span class="st">&quot;No other&quot;</span> <span class="st">&quot;With a&quot;</span>
                  <span class="st">&quot;And at&quot;</span> <span class="st">&quot;What a&quot;</span> <span class="st">&quot;Of the&quot;</span>
                  <span class="st">&quot;O please&quot;</span> <span class="st">&quot;So that&quot;</span> <span class="st">&quot;And all&quot;</span> <span class="st">&quot;When they&quot;</span>
                  <span class="st">&quot;But before&quot;</span> <span class="st">&quot;Whoso had&quot;</span> <span class="st">&quot;And nobody&quot;</span> <span class="st">&quot;And it's&quot;</span>
                  <span class="st">&quot;For any&quot;</span> <span class="st">&quot;For example,&quot;</span> <span class="st">&quot;Also in&quot;</span> <span class="st">&quot;In contrast&quot;</span>])</code></pre></div>
<p>Also, I want to fix a bit of the punctuation of the generated text. In particular, I want to trim the text to the last punctuation in the text. Then, if it ends in a comma, I want to replace it with a period. If there is no punctuation, I want to drop the last word and add a period. I also want to clean up an quotes that get escaped in the text.</p>
<p>Adding a test for that in our <em>generator_test.clj</em> file:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">deftest</span><span class="fu"> test-end-at-last-puntcuation</span>
  (<span class="kw">testing</span> <span class="st">&quot;Ends at the last puncuation&quot;</span>
    (<span class="kw">is</span> (<span class="kw">=</span> <span class="st">&quot;In a tree so happy are we.&quot;</span>
           (end-at-last-punctuation <span class="st">&quot;In a tree so happy are we. So that&quot;</span>)))
    (<span class="kw">testing</span> <span class="st">&quot;Replaces ending comma with a period&quot;</span>
    (<span class="kw">is</span> (<span class="kw">=</span> <span class="st">&quot;In a tree so happy are we.&quot;</span>
           (end-at-last-punctuation <span class="st">&quot;In a tree so happy are we, So that&quot;</span>))))
    (<span class="kw">testing</span> <span class="st">&quot;If there are no previous puncations, just leave it alone and add one at the end&quot;</span>
      (<span class="kw">is</span> ( <span class="kw">=</span> <span class="st">&quot;In the light of the blue moon.&quot;</span>
              (end-at-last-punctuation  <span class="st">&quot;In the light of the blue moon there&quot;</span>))))
    (<span class="kw">testing</span> <span class="st">&quot;works with multiple punctuation&quot;</span>
      (<span class="kw">is</span> ( <span class="kw">=</span> <span class="st">&quot;In the light of the blue moon.  We danced merrily.&quot;</span>
              (end-at-last-punctuation  <span class="st">&quot;In the light of the blue moon.  We danced merrily.  Be&quot;</span>))))))</code></pre></div>
<p>We can make this test pass in our <em>generator.clj</em> file, by using some string and regex functions.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> end-at-last-punctuation </span>[text]
  (<span class="kw">let</span> [trimmed-to-last-punct (<span class="kw">apply</span> <span class="kw">str</span> (<span class="kw">re-seq</span> <span class="st">#&quot;[\s\w]+[^.!?,]*[.!?,]&quot;</span> text))
        trimmed-to-last-word (<span class="kw">apply</span> <span class="kw">str</span> (<span class="kw">re-seq</span> <span class="st">#&quot;.*[^a-zA-Z]+&quot;</span> text))
        result-text (<span class="kw">if</span> (<span class="kw">empty?</span> trimmed-to-last-punct)
                      trimmed-to-last-word
                      trimmed-to-last-punct)
        cleaned-text (clojure.string/replace result-text <span class="st">#&quot;[,| ]$&quot;</span> <span class="st">&quot;.&quot;</span>)]
    (clojure.string/replace cleaned-text <span class="st">#&quot;</span>\&quot;<span class="st">&quot;</span> <span class="st">&quot;'&quot;</span>)))</code></pre></div>
<p>Using this, we can now make a <code>tweet-text</code> function that will randomly choose a prefix from our prefix list and generate our mashup text.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> tweet-text </span>[]
  (<span class="kw">let</span> [text (generate-text (<span class="kw">-&gt;</span> prefix-list shuffle <span class="kw">first</span>) functional-leary)]
    (end-at-last-punctuation text)))

(tweet-text)
<span class="co">;; -&gt; &quot;With a wreath of shrimps in her short white hair.</span>
<span class="co">;;     And before the end of this period Hickey sent an email</span>
<span class="co">;;     announcing the language Hope.&quot;</span></code></pre></div>
<p>Alright, that last one made me smile.</p>
<p>We now have a function that will generate tweets for us. The next step is to hook it up to a Twitter account so that we can share our smiles with the world.</p>
<h2 id="hooking-the-bot-up-to-twitter">Hooking the bot up to Twitter</h2>
<p>To hook up our bot to twitter, you need to create a twitter account. Once you do that, need to do the following:</p>
<ul>
<li>Go to <a href="https://apps.twitter.com/" class="uri">https://apps.twitter.com/</a> to create new twitter application. You will want to set the permission so that it can post to the twitter account. This will give you a <em>Consumer Key (API Key)</em> and a <em>Consumer Secret (API Secret)</em>.</li>
<li>Go to the the <em>Keys and Access Tokens</em> section of the application. On the bottom half there is a button that says <em>Create my access token</em>, click it. It will generate two more key pieces of information for you: <em>Access Token</em> and <em>Access Token Secret</em>.</li>
</ul>
<p>Please note that these setting are sensitive and should not be checked into github or shared publicly. To help make our twitter account access, we are going to need the help of two libraries. The first is <a href="https://github.com/adamwynne/twitter-api">twitter-api</a> that will help us make our api calls. The second is <a href="https://github.com/weavejester/environ">environ</a> that will help us keep our login information safe.</p>
<p>Add both libraries to your <em>project.clj</em></p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure"> [twitter-api <span class="st">&quot;0.7.8&quot;</span>]
 [environ <span class="st">&quot;1.0.0&quot;</span>]</code></pre></div>
<p>Also add the <code>lein-environ</code> plugin to your <em>project.clj</em> as well.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="kw">:plugins</span> [[lein-environ <span class="st">&quot;1.0.0&quot;</span>]]</code></pre></div>
<p>The environ plugin allows us to pass configuration information from environment settings or a <em>profiles.clj</em> file that can be ignored and <strong>not checked</strong> in. Let’s go ahead and add a <em>profiles.clj</em> file to the root of our project and put in all our twitter account info.</p>
<p><em>Danger: Do not check in your twitter keys and push to a public repo!</em></p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">{<span class="kw">:dev</span>  {<span class="kw">:env</span> {<span class="kw">:app-consumer-key</span> <span class="st">&quot;foo&quot;</span>
              <span class="kw">:app-consumer-secret</span> <span class="st">&quot;bar&quot;</span>
              <span class="kw">:user-access-token</span> <span class="st">&quot;foo2&quot;</span>
              <span class="kw">:user-access-secret</span> <span class="st">&quot;bar2&quot;</span>}}}</code></pre></div>
<p>Also add both the twitter-api and the environ library to the project namespace in the <em>generator.clj</em> file.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.generator
  (<span class="kw">:require</span> [twitter.api.restful <span class="kw">:as</span> twitter]
            [twitter.oauth <span class="kw">:as</span> twitter-oauth]
            [environ.core <span class="kw">:refer</span> [env]]))</code></pre></div>
<p>This will allow us to define <code>my-creds</code> that will make our creditionals for our twitter app.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> my-creds </span>(twitter-oauth/make-oauth-creds (env <span class="kw">:app-consumer-key</span>)
                                              (env <span class="kw">:app-consumer-secret</span>)
                                              (env <span class="kw">:user-access-token</span>)
                                              (env <span class="kw">:user-access-secret</span>)))</code></pre></div>
<p>Now that we can talk to our twitter account. We can finally write a <code>status-update</code> function that will post our markov chain generated text.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> status-update </span>[]
  (<span class="kw">let</span> [tweet (tweet-text)]
    (<span class="kw">println</span> <span class="st">&quot;generated tweet is :&quot;</span> tweet)
    (<span class="kw">println</span> <span class="st">&quot;char count is:&quot;</span> (<span class="kw">count</span> tweet))
    (<span class="kw">when</span> (<span class="kw">not-empty</span> tweet)
      (<span class="kw">try</span> (twitter/statuses-update <span class="kw">:oauth-creds</span> my-creds
                                    <span class="kw">:params</span> {<span class="kw">:status</span> tweet})
           (<span class="kw">catch</span> Exception <span class="kw">e</span> (<span class="kw">println</span> <span class="st">&quot;Oh no! &quot;</span> (.getMessage <span class="kw">e</span>)))))))</code></pre></div>
<p>Giving it a try:</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(status-update)
<span class="co">;; -&gt; {.... :text &quot;For example, the functions doesFileExist and</span>
<span class="co">;;                 removeFile in the 1980s</span>
<span class="co">;;                 in the nights of June.&quot;}}</span></code></pre></div>
<div class="figure">
<img src="http://c4.staticflickr.com/8/7617/16905225975_07da52ac87_b.jpg" />

</div>
<p>Hooray! We are almost there. We next need a way to run this status update on a periodic basis, having it post automatically for us.</p>
<h2 id="automating-our-tweets">Automating our tweets</h2>
<p>To have this run from the command line in an automated fashion, we are going to do two things. The first is to use the <a href="https://github.com/overtone/at-at">Overtone at-at library</a> for scheduling. And the other thing that we need to do is to add a main function to the <em>generator.clj</em> file and to setup up the project so that it can run with <code>lein trampoline run</code>.</p>
<p>So first, modify the <em>project.clj</em> file to have the <em>at-at</em> library, as well as the main function for the namespace.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure"> <span class="kw">:dependencies</span> [[org.clojure/clojure <span class="st">&quot;1.6.0&quot;</span>]
                 [overtone/at-at <span class="st">&quot;1.2.0&quot;</span>]
                 [twitter-api <span class="st">&quot;0.7.8&quot;</span>]
                 [environ <span class="st">&quot;1.0.0&quot;</span>]]
  <span class="kw">:main</span> markov-elear.generator
  <span class="kw">:min-lein-version</span> <span class="st">&quot;2.0.0&quot;</span>
  <span class="kw">:plugins</span> [[lein-environ <span class="st">&quot;1.0.0&quot;</span>]]
  <span class="kw">:profiles</span> {<span class="kw">:dev</span> {<span class="kw">:plugins</span> [[com.jakemccrary/lein-test-refresh <span class="st">&quot;0.7.0&quot;</span>]]}})</code></pre></div>
<p>Then, going back to the <em>generator.clj</em> file, first add the <em>overtone/at-at</em> library to the namespace. Then, define a pool for the scheduling process, and add in a <code>-main</code> function to tweet for us every 8 hours.</p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> markov-elear.generator
  (<span class="kw">:require</span> [overtone.at-at <span class="kw">:as</span> overtone]
            [twitter.api.restful <span class="kw">:as</span> twitter]
            [twitter.oauth <span class="kw">:as</span> twitter-oauth]
            [environ.core <span class="kw">:refer</span> [env]]))


(<span class="kw">def</span><span class="fu"> my-pool </span>(overtone/mk-pool))

(<span class="kw">defn</span><span class="fu"> -main </span>[&amp; args]
  <span class="co">;; every 8 hours</span>
  (<span class="kw">println</span> <span class="st">&quot;Started up&quot;</span>)
  (<span class="kw">println</span> (tweet-text))
  (overtone/every (<span class="kw">*</span> <span class="dv">1000</span> <span class="dv">60</span> <span class="dv">60</span> <span class="dv">8</span>) #(<span class="kw">println</span> (status-update)) my-pool))</code></pre></div>
<p>Now we should be able to try this from the command line.</p>
<pre><code>lein trampoline run</code></pre>
<p>and see something like the following</p>
<pre><code>Started up
Are the best of food for me!
generated tweet is : With only a beautiful pea-green veil Tied with a flumpy sound.
char count is: 62
{... :text With only a beautiful pea-green veil Tied with a flumpy sound.}</code></pre>
<p>At this point our program is complete. We could happily leave it running locally. It is much better though, to deploy it somewhere. <a href="http://heroku.com/" class="uri">http://heroku.com/</a> is a fantastic place for this. It provides free hosting and has nice Clojure support.</p>
<h2 id="deploying-to-heroku">Deploying to Heroku</h2>
<p>The first thing you will need to do is to create an account on Heroku. It is free of charge. You can create your login at <a href="https://signup.heroku.com/dc" class="uri">https://signup.heroku.com/dc</a>.</p>
<p>Next, you will need the <em>Heroku Toolbelt</em>. This gives you a nice command line tool to configure and deploy applications. You can download it from <a href="https://devcenter.heroku.com/articles/getting-started-with-clojure#set-up" class="uri">https://devcenter.heroku.com/articles/getting-started-with-clojure#set-up</a>.</p>
<p>Once you have downloaded the tool, you will need to configure it with your username and password. You can do this at the command line by typing <code>heroku login</code>. You will be prompted for your email and password.</p>
<pre><code>-&gt; heroku login
Enter your Heroku credentials.
Email:
Password:</code></pre>
<p>Now you are all set to configure your project.</p>
<p>If you haven’t initialized it yet as a git repo, do so with</p>
<pre><code>git init</code></pre>
<p>After that, we need to tell Heroku how to start up our app. We do this with a <em>Procfile</em> in the main project directory. Go ahead and add the file with the following contents.</p>
<pre><code>worker: lein trampoline run</code></pre>
<p>This will tell Heroku to run our program as a background worker, (rather than a web app), and start it up with <code>lein trampoline run</code>.</p>
<p>The next step is to create an app on Heroku for it. This will get Heroku ready to receive your code for deployment. Type <code>heroku create</code> into your command prompt at the root of the project. You will see.</p>
<pre><code>-&gt; heroku create
Creating calm-reaches-2803... done, stack is cedar-14
https://calm-reaches-2803.herokuapp.com/ | https://git.heroku.com/calm-reaches-2803.git
Git remote heroku added</code></pre>
<p>It created a random application name for you, (which you can rename later through the console). It also added a repository called <em>heroku</em> to our git config. Once we push our code here, it will automatically deploy.</p>
<p>You will also need to setup your Twitter creditionals on the Heroku account so it will be able to talk to it. You can do this with <a href="https://devcenter.heroku.com/articles/config-vars">heroku config</a>.</p>
<p>You need to do a command line <code>heroku config</code> for each one of our configurations:</p>
<pre><code>heroku config:set APP_CONSUMER_KEY=foo
heroku config:set APP_CONSUMER_SECRET=bar
heroku config:set USER_ACCESS_TOKEN=foo2
heroku config:set USER_ACCESS_SECRET=bar2</code></pre>
<p>Finally, we can push all of our changes to Heroku with:</p>
<pre><code>git push heroku master</code></pre>
<p>You should see it deploy and tweet for you!</p>
<p>If you need to check the logs, you can do it with <code>heroku logs</code>.</p>
<p>We have successfully created and deployed a markov bot that will tweet for us. Let’s recap what we have done so far.</p>
<h2 id="summary">Summary</h2>
<ul>
<li>Use Emacs REPL integration to play and experiment with the code. This is what I call an early sculpting with code phase, or <em>REPL Driven Development</em>.</li>
<li>As soon as we have a good idea where we are headed, switch into a more Test Driven Development cycle with the <em>lein-test-refresh</em> plugin.</li>
<li>Create the core of our code to generate and walk our Markov Chain.</li>
<li>Create ways to parse input text files to <em>train</em> our bot on.</li>
<li>Artistically select some entry points into our chain using prefixes. Also artistically, fix up the puncuation of the resulting text.</li>
<li>Set up a Twitter account.</li>
<li>Use the <em>environ</em> library to handle our environment specific twitter configuration.</li>
<li>Use the <em>twitter-api</em> library to talk to the twitter account</li>
<li>Use the <em>at-at</em> library to schedule a job periodically to tweet for us.</li>
<li>Deploy the application to Heroku.</li>
</ul>
<p>I hope you have enjoyed our Clojure bot creating journey. The full code for this project can be found at <a href="https://github.com/gigasquid/markov-elear" class="uri">https://github.com/gigasquid/markov-elear</a>. The twitter bot lives at <a href="https://twitter.com/FunctionalELear">functionalELear</a></p>
<p>I encourage you to experiment and create your own <em>art bots</em> and, of course, to continue to explore and enjoy the wonderful world of Clojure.</p>
<p><em>Special thanks to <a href="https://twitter.com/jakemcc">Jake McCrary</a> and <a href="https://twitter.com/p9k">Paul Henrich</a> for reviewing this post and providing wonderful feedback.</em></p>
  </div>
</div>

<div class="row">
  <div class="col-lg-10 col-lg-offset-1">
    <hr />
  </div>
</div>


<div class="row">
  <div class="col-lg-6 col-lg-6">
    <div class="col-lg-5 col-lg-offset-5">
      <img class="img-responsive" src="../../../posts/clojure/1/images/headshot.png" alt>
    </div>
  </div>

  <div class="col-lg-6 col-lg-6">
    <h3>Carin Meier</h3>
    <h4>Clojure</h4>
    <h3><small> Author of Living Clojure, Engineer, Entrepreneur</small></h3>
    <p><a href="http://gigasquidsoftware.com">Carin</a> studied physics in college, and ended up as a software developer. Her passions led her to developing home automation and control libraries for drones. She helps lead the <a href="https://cincyfp.wordpress.com/">Cincinnati Functional Programmers</a> and is a frequent conference speaker, keynoting OSCON and Strange Loop. To top it off Carin is the author of the upcoming book <a href="http://shop.oreilly.com/product/0636920034292.do">Living Clojure</a> from O'Reilly.</p>
    <a class="btn btn-primary" href="../../../posts/clojure/1/index.html">Read <span class="glyphicon glyphicon-chevron-right"></span></a>
  </div>
</div>

      </div>

      <footer>
        <hr />
        <div class="row">
          <div class="col-md-4 col-md-offset-8">
            <p class="text-right">
              <small>Except where otherwise noted.</small>
              <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details">
                <img src="../../../images/cc.png" alt="Creative Commons Attribution Non-Commercial No Derivative License" />
              </a>
            </p>
          </div>
        </div>
      </footer>
    </div>

    <!-- JavaScript -->
    <script src="../../../js/jquery-1.10.2.js"></script>
    <script src="../../../js/bootstrap.js"></script>

  </body>
</html>
